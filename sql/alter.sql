-- Adding an identity column to an existing table

CREATE TABLE shape
(
    shape_id   INT     NOT NULL,
    shape_name VARCHAR NOT NULL
);

-- adding an identity column to an existing table (keep in mind to alter into the `identity column` the column should be NOT NULL else it will throw an error
ALTER TABLE shape
    ALTER COLUMN shape_id ADD GENERATED ALWAYS AS IDENTITY;

-- changing the type of identify column
ALTER TABLE shape
    ALTER COLUMN shape_id SET GENERATED BY DEFAULT;

-- removing the generated by identity constraint
ALTER TABLE shape
    ALTER COLUMN shape_id DROP IDENTITY IF EXISTS;

-- # ALTER TABLE

-- ALTER TABLE table_name ADD COLUMN column_name datatype column_constraint;
-- ALTER TABLE table_name DROP COLUMN column_name;
-- ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name;
-- ALTER TABLE table_name ALTER COLUMN column_name [SET DEFAULT value | DROP DEFAULT];
-- ALTER TABLE table_name ALTER COLUMN column_name [SET NOT NULL| DROP NOT NULL];
-- ALTER TABLE table_name ADD CHECK expression;
-- ALTER TABLE table_name ADD CONSTRAINT constraint_name constraint_definition;
-- ALTER TABLE table_name RENAME TO new_table_name;

CREATE TABLE IF NOT EXISTS links
(
    link_id serial PRIMARY KEY,
    title   VARCHAR(512)  NOT NULL,
    url     VARCHAR(1024) NOT NULL
);

-- To add a new column named active, you use the following statement:
ALTER TABLE links
    ADD COLUMN target VARCHAR(10);

-- rename an existing column
ALTER TABLE links
    RENAME title to link_title;

-- drop a column from existing table
ALTER TABLE links
    DROP COLUMN is_active;

-- set the default value to an existing field or column
ALTER TABLE links
    ALTER COLUMN target SET DEFAULT '_blank';

INSERT INTO links (link_title, url)
VALUES ('PostgreSQL Tutorial', 'https://neon.tech/postgresql/');

-- The following statement adds a CHECKcondition to the targetcolumn so that the targetcolumn only accepts the following values: _self, _blank, _parent, and _top:
ALTER TABLE links
    ADD CHECK (target IN ('_self', '_blank', '_parent', '_top'));

-- The value 'whatever' fails the above check so it won't be inserted therefore it will throw error when executed
INSERT INTO links(link_title, url, target)
VALUES ('PostgreSQL', 'http://www.postgresql.org/', 'whatever');

-- adds a UNIQUE constraint to the url column of the links table:
ALTER TABLE links
    ADD CONSTRAINT unique_url UNIQUE (url);

-- it will fail since this url already exist
INSERT INTO links(link_title, url)
VALUES ('PostgreSQL', 'https://neon.tech/postgresql/');

select *
from links;

-- # RENAME TABLE

-- ALTER TABLE <TABLE NAME> IF EXISTS RENAME <NEW TABLE NAME>

CREATE TABLE vendors
(
    id   serial PRIMARY KEY,
    name VARCHAR NOT NULL
);

select *
from vendors;

ALTER TABLE vendors
    RENAME TO suppliers;

select *
from suppliers;

-- see the constraints of a table (e.g. 'suppliers')
SELECT conname                                AS constraint_name,
       contype                                AS constraint_type,
       condeferrable,
       condeferred,
       pg_catalog.pg_get_constraintdef(c.oid) AS constraint_definition
FROM pg_catalog.pg_constraint c
         JOIN
     pg_catalog.pg_class t ON c.conrelid = t.oid
WHERE t.relname = 'suppliers';

-- change the constraint name
ALTER TABLE suppliers
    RENAME CONSTRAINT vendors_pkey TO suppliers_pkey;

-- Renaming a table that has dependent objects

CREATE TABLE customer_groups
(
    id   SERIAL PRIMARY KEY,
    name VARCHAR NOT NULL
);

CREATE TABLE customers
(
    id       SERIAL PRIMARY KEY,
    name     VARCHAR(255) NOT NULL,
    group_id INT          NOT NULL,
    FOREIGN KEY (group_id) REFERENCES customer_groups (id)
        ON DELETE CASCADE
        ON UPDATE CASCADE
);

-- Second, create a view based on the customers and customer_groups tables:
CREATE VIEW customer_data
AS
SELECT c.id,
       c.name,
       g.name customer_group
FROM customers c
         INNER JOIN customer_groups g ON g.id = c.group_id;

-- so, when renamed the customer_groups table to groups: PostgreSQL will automatically update its dependent objects such as foreign key constraints (customers), views (customers), and indexes.
-- N.B: now, doing \d (in psql) customers which has foreign key constraints from renamed table, foreign key constraint was updated and referenced the groups from customer_groups
ALTER TABLE customer_groups
    RENAME TO groups;

-- in psql, to show the customer_data view in psql: copy-paste without quotes '\d+ customer_data' (it will show groups not customer_groups)
select *
from customer_data;

-- # ADD COLUMN: Add One or More Columns to a Table

-- ALTER TABLE table_name
-- ADD COLUMN column_name1 data_type constraint,
-- ADD COLUMN column_name2 data_type constraint,
-- ADD COLUMN column_namen data_type constraint;

DROP TABLE IF EXISTS customers2 CASCADE;

CREATE TABLE IF NOT EXISTS customers2
(
    id            SERIAL PRIMARY KEY,
    customer_name VARCHAR(255) NOT NULL
);

ALTER TABLE customers
    ADD COLUMN fax   VARCHAR(25),
    ADD COLUMN email VARCHAR(400);

INSERT INTO customers2 (customer_name)
VALUES ('Apple'),
       ('Samsung'),
       ('Sony')
RETURNING *;

-- add the contact_name column to the customers table:
-- This will get an `error` because This is because the contact_name column has the NOT NULL constraint.
-- When PostgreSQL added the column, (by default) this new column received NULL value, which violates the NOT NULL constraint.
ALTER TABLE customers2
    ADD COLUMN contact_name VARCHAR(255) NOT NULL;

-- solution: 1) remove the `NOT NULL` constraint 2) then manually update each row's contact_name 3) now set column_name to not null
ALTER TABLE customers2
    ADD COLUMN contact_name VARCHAR(255);

UPDATE customers2
SET contact_name = 'John Doe'
WHERE id = 1;

UPDATE customers2
SET contact_name = 'Mary Doe'
WHERE id = 2;

UPDATE customers2
SET contact_name = 'Lily Bush'
WHERE id = 3;

ALTER TABLE customers2
    ALTER COLUMN contact_name SET NOT NULL;

-- Adding a column with a NOT NULL constraint to a table that already has data

select *
from customers2;

-- # Remove One or More Columns of a Table

-- ALTER TABLE table_name DROP COLUMN column_name CASCADE;
-- ALTER TABLE table_name DROP COLUMN IF EXISTS column_name;

-- ALTER TABLE table_name
-- DROP COLUMN IF EXISTS  column_name1,
-- DROP COLUMN IF EXISTS column_name2;

CREATE TABLE publishers
(
    publisher_id SERIAL PRIMARY KEY,
    name         VARCHAR(255) NOT NULL
);

CREATE TABLE categories
(
    category_id SERIAL PRIMARY KEY,
    name        VARCHAR(255) NOT NULL
);

CREATE TABLE books
(
    book_id        SERIAL PRIMARY KEY,
    title          VARCHAR(255) NOT NULL,
    isbn           VARCHAR(255) NOT NULL,
    published_date DATE         NOT NULL,
    description    VARCHAR,
    category_id    INT          NOT NULL,
    publisher_id   INT          NOT NULL,
    FOREIGN KEY (publisher_id)
        REFERENCES publishers (publisher_id),
    FOREIGN KEY (category_id)
        REFERENCES categories (category_id)
);

CREATE VIEW book_info
AS
SELECT book_id,
       title,
       isbn,
       published_date,
       name
FROM books b
         INNER JOIN publishers
                    USING (publisher_id)
ORDER BY title;

-- Drop a column (so when this 'category_id' dropped then any associated foreign key constraint for this 'category_id' also removed)
ALTER TABLE books
    drop column if exists category_id;

-- But unlike "category_id" that wasn't being referenced elsewhere than the current table, "publisher_id" can't be dropped since publisher_id is being used in the "view_info"
-- Solution: Drop the reference table i.e. view_info, then remove it from books or drop the foreign key constraint

-- Drop the foreign key constraint (but keep the view intact)
ALTER TABLE books
    DROP CONSTRAINT IF EXISTS books_publisher_id_fkey;

-- Add a temporary column to preserve the data
ALTER TABLE books
    ADD COLUMN publisher_id_temp INT;

-- Drop the column
ALTER TABLE books
    DROP COLUMN IF EXISTS publisher_id;

-- Recreate the foreign key constraint if necessary
ALTER TABLE books
    ADD CONSTRAINT books_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES publishers (publisher_id);

-- drop multiple columns
ALTER TABLE books
    DROP COLUMN isbn,
    DROP COLUMN description;

select *
from books;

-- # change datatype
CREATE TABLE assets
(
    id            serial PRIMARY KEY,
    name          TEXT    NOT NULL,
    asset_no      VARCHAR NOT NULL,
    description   TEXT,
    location      TEXT,
    acquired_date DATE    NOT NULL
);

INSERT INTO assets(name, asset_no, location, acquired_date)
VALUES ('Server', '10001', 'Server room', '2017-01-01'),
       ('UPS', '10002', 'Server room', '2017-01-01')
RETURNING *;

ALTER TABLE assets
    ALTER COLUMN name TYPE VARCHAR(255);

ALTER TABLE assets
    ALTER COLUMN location TYPE VARCHAR(255),
    ALTER COLUMN description TYPE VARCHAR(255);

-- To both change the type of column and cast data from VARCHAR to INT, you can use the USING clause:
ALTER TABLE assets
    ALTER COLUMN asset_no TYPE INT USING asset_no::integer;

-- # DROP TABLE
-- If the table is used in other areas such as views, triggers, functions, and stored procedures, you cannot remove it. In this case, you have two options:

-- Use the CASCADE option to remove the table and its dependent objects.
-- Use the RESTRICT option rejects the removal if there is any object depending on the table. The RESTRICT option is the default if you donâ€™t explicitly specify it in the DROP TABLE statement.

CREATE TABLE authors
(
    author_id INT PRIMARY KEY,
    firstname VARCHAR(50) NOT NULL,
    lastname  VARCHAR(50) NOT NULL
);

CREATE TABLE pages
(
    page_id   SERIAL PRIMARY KEY,
    title     VARCHAR(255) NOT NULL,
    contents  TEXT,
    author_id INT          NOT NULL,
    FOREIGN KEY (author_id) REFERENCES authors (author_id)
);

select *
from authors;
select *
from pages;

DROP TABLE IF EXISTS authors, pages cascade;

-- # TEMP TABLE
-- In PostgreSQL, a temporary table is a table that exists only during a database session (normal session or during transaction session).
-- It is created and used within a single database session and is automatically dropped at the end of the session.

-- N.B: both permanent and temp table can have same name, but in that case *temp table has to be deleted first to use the permanent table, example below

CREATE TABLE customers
(
    id   SERIAL PRIMARY KEY,
    name VARCHAR NOT NULL
);

CREATE TEMP TABLE customers(
    customer_id INT
);

-- This will query from the (temp table) i.e. customers not the permanent "customers"
SELECT * FROM customers;

-- This will drop the (temp table) i.e. customers not the permanent "customers"
DROP TABLE customers cascade;

-- show all the views
SELECT table_schema, table_name
FROM information_schema.views
WHERE table_schema NOT IN ('pg_catalog', 'information_schema')
ORDER BY table_schema, table_name;

-- # TRUNCATE

CREATE TABLE orders(
  order_id SERIAL PRIMARY KEY,
  customer_name VARCHAR(255) NOT NULL,
  ordered_date DATE NOT NULL,
  status VARCHAR(20) NOT NULL
);

CREATE TABLE order_items (
  order_id INT NOT NULL,
  item_id INT NOT NULL,
  product_name VARCHAR(255) NOT NULL,
  quantity INT NOT NULL,
  FOREIGN KEY (order_id)
     REFERENCES orders(order_id) ON DELETE CASCADE ON UPDATE CASCADE,
  PRIMARY KEY (order_id, item_id)
);

INSERT INTO orders (customer_name, ordered_date, status)
VALUES
  ('John Doe', '2024-01-25', 'Processing'),
  ('Jane Smith', '2024-01-26', 'Shipped'),
  ('Bob Johnson', '2024-01-27', 'Delivered');

INSERT INTO order_items (order_id, item_id, product_name, quantity)
VALUES
  (1, 1, 'A', 2),
  (1, 2, 'B', 1),
  (2, 1, 'C', 3),
  (3, 1, 'D', 5),
  (3, 2, 'E', 2);

TRUNCATE TABLE orders cascade;

-- TRUNCATE TABLE orders RESTART IDENTITY; resets the sequence, so new values will start from the initial value (e.g., 1).
TRUNCATE TABLE orders RESTART IDENTITY;