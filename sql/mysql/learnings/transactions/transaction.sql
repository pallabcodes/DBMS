-- TRANSACTION: A database transaction is a single unit of work that consists of one or more operations e.g. of a transaction is a bank transfer from one account to another. A complete transaction must ensure a balance between the sender and receiver accounts.
-- This implies that if the sender account transfers X amount, the receiver receives exactly X amount, neither more nor less.

-- A PostgreSQL transaction is atomic, consistent, isolated, and durable. These properties are often referred to collectively as ACID:

-- Atomicity guarantees that the transaction is completed in an all-or-nothing manner.
-- Consistency ensures that changes to data written to the database are valid and adhere to predefined rules.
-- Isolation determines how the integrity of a transaction is visible to other transactions.
-- Durability ensures that transactions that have been committed are permanently stored in the database.

DROP TABLE IF EXISTS accounts;

CREATE TABLE accounts (
    id INT GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(100) NOT NULL,
    balance DEC(15,2) NOT NULL CHECK(balance >= 0),
    PRIMARY KEY(id)
);

INSERT INTO accounts(name,balance) VALUES('Bob',10000);

select * from accounts;

-- For example, the following statements start a new transaction and insert a new account into the accounts table:

BEGIN;

INSERT INTO accounts(name,balance)
VALUES('Alice',10000);

COMMIT; -- or, END and to discard this query ROLLBACK

select * from accounts;

-- Start XA transaction
XA START 'xid-001';

-- Local operations
UPDATE accounts SET balance = balance - 1000 WHERE name = 'Bob';

-- Prepare phase
XA END 'xid-001';
XA PREPARE 'xid-001';

-- On all involved databases, then:
XA COMMIT 'xid-001'; -- or XA ROLLBACK 'xid-001';

-- 2. Savepoint for Partial Rollback
-- Scenario: Rollback only a part of a transaction if a step fails.

START TRANSACTION;
UPDATE accounts SET balance = balance - 500 WHERE name = 'Bob';
SAVEPOINT after_bob;
UPDATE accounts SET balance = balance + 500 WHERE name = 'Alice';
-- Suppose this fails, rollback to savepoint:
ROLLBACK TO after_bob;
-- Continue with other operations...
COMMIT;

-- 3. Deadlock Detection and Retry Logic (Pseudo-code for App Layer)
-- Scenario: Application retries transaction on deadlock.

-- Explanation: Fine-grained error recovery within a transaction.

-- Pseudo-code (to be implemented in app logic)
REPEAT
  START TRANSACTION;
  -- ...SQL operations...
  COMMIT;
UNTIL success OR error != 'Deadlock found when trying to get lock';

-- Explanation: Ensures reliability in high-contention environments.

-- 4. Transactional Auditing with JSON
-- Scenario: Log all changes in a transaction as a JSON audit trail.

START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE name = 'Bob';
INSERT INTO audit_log(event_type, event_data)
VALUES ('debit', JSON_OBJECT('user', 'Bob', 'amount', 100, 'ts', NOW()));
COMMIT;

-- Explanation: Ensures every transaction is auditable and traceable.

-- 5. Transactional Consistency with Foreign Key Cascades

-- Scenario: Ensure referential integrity with cascading deletes/updates.

ALTER TABLE accounts
ADD CONSTRAINT fk_customer
FOREIGN KEY (id) REFERENCES customers(id)
ON DELETE CASCADE ON UPDATE CASCADE;

-- Explanation: Changes in parent table are automatically reflected in child.

-- 6. Transactional Locking for Pessimistic Concurrency

-- Scenario: Lock rows to prevent concurrent modifications.

START TRANSACTION;
SELECT * FROM accounts WHERE name = 'Bob' FOR UPDATE;
-- ...do updates...
COMMIT;

-- Explanation: Prevents lost updates in high-concurrency scenarios.

-- 7. Transactional Outbox Pattern (for Eventual Consistency)

-- Scenario: Write to an outbox table within the transaction for async processing.

START TRANSACTION;
UPDATE accounts SET balance = balance - 200 WHERE name = 'Bob';
INSERT INTO outbox(event_type, payload, processed) VALUES ('debit', '{"user":"Bob","amount":200}', 0);
COMMIT;


-- Explanation: Enables reliable integration with external systems.

-- 8. Read Consistency with Transaction Isolation Levels
-- Scenario: Set isolation level for repeatable reads.


SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT * FROM accounts WHERE name = 'Bob';
-- ...other operations...
COMMIT;

-- Explanation: Prevents non-repeatable reads and phantom reads.

-- 9. Full Transaction Rollback on Error
-- Scenario: If any step fails, the whole transaction is rolled back.
START TRANSACTION;
UPDATE accounts SET balance = balance - 1000 WHERE name = 'Bob';
UPDATE accounts SET balance = balance + 1000 WHERE name = 'Alice';
-- Simulate error: Uncomment to test rollback
-- SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Simulated failure';
COMMIT;
-- If error occurs, ROLLBACK is automatic.

-- Scenario: Violating a CHECK constraint (balance >= 0) aborts the transaction.
START TRANSACTION;
UPDATE accounts SET balance = balance - 20000 WHERE name = 'Bob';
COMMIT; -- Fails, transaction is rolled back

-- Scenario: Once COMMIT is issued, data is persisted even after crash.
-- (Cannot demo crash in SQL, but you can test by committing, then restarting MySQL and checking data.)
-- Tuning durability (not for prod):
-- SET GLOBAL innodb_flush_log_at_trx_commit = 2; -- Less durable, more performant

-- To test, open two sessions (Session 1 and Session 2):

-- a) Dirty Read (READ UNCOMMITTED)
-- Session 1:
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT * FROM accounts WHERE name = 'Bob';
-- Session 2 (before commit):
UPDATE accounts SET balance = 0 WHERE name = 'Bob';
-- Session 1: SELECT * FROM accounts WHERE name = 'Bob'; -- Sees uncommitted change

-- b) Non-Repeatable Read (READ COMMITTED)
-- Session 1:
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT * FROM accounts WHERE name = 'Bob';
-- Session 2:
UPDATE accounts SET balance = 12345 WHERE name = 'Bob'; COMMIT;
-- Session 1: SELECT * FROM accounts WHERE name = 'Bob'; -- Value changes

-- c) Phantom Read (REPEATABLE READ)
-- Session 1:
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT * FROM accounts WHERE balance > 1000;
-- Session 2:
INSERT INTO accounts(name, balance) VALUES('Eve', 2000); COMMIT;
-- Session 1: SELECT * FROM accounts WHERE balance > 1000; -- Eve may or may not appear

-- d) Serializable
-- Session 1:
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;
SELECT * FROM accounts WHERE name = 'Bob';
-- Session 2: Any write to same row will block until Session 1 commits.

-- Scenario: DDL is atomic with InnoDB (e.g., add column, create index)
START TRANSACTION;
ALTER TABLE accounts ADD COLUMN last_updated TIMESTAMP NULL;
ROLLBACK; -- Table schema reverts, no partial state

DELIMITER //
CREATE PROCEDURE transfer_funds(IN from_user VARCHAR(100), IN to_user VARCHAR(100), IN amt DECIMAL(15,2))
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
      ROLLBACK;
    END;
  START TRANSACTION;
  UPDATE accounts SET balance = balance - amt WHERE name = from_user;
  UPDATE accounts SET balance = balance + amt WHERE name = to_user;
  COMMIT;
END //
DELIMITER ;

-- Scenario: Use binlog position to restore to a consistent state after a transaction.
-- (Requires backup tools and binlog access; see MySQL docs for full workflow.)

-- Scenario: Atomically enable/disable a feature for all users.
START TRANSACTION;
UPDATE feature_flags SET enabled = 1 WHERE feature = 'new_ui';
COMMIT;

-- Scenario: Write to both main and canary tables in a transaction for safe rollout.
START TRANSACTION;
UPDATE accounts SET balance = balance - 10 WHERE name = 'Bob';
INSERT INTO accounts_canary SELECT * FROM accounts WHERE name = 'Bob';
COMMIT;

-- Scenario: Call an ML UDF to score a transaction before committing.
START TRANSACTION;
UPDATE accounts SET risk_score = ml_score(balance) WHERE name = 'Bob';
COMMIT;

DELIMITER //
CREATE TRIGGER audit_accounts_update
AFTER UPDATE ON accounts
FOR EACH ROW
BEGIN
  INSERT INTO audit_log(event_type, event_data)
  VALUES ('update', JSON_OBJECT('user', NEW.name, 'old_balance', OLD.balance, 'new_balance', NEW.balance, 'ts', NOW()));
END //
DELIMITER ;

DELIMITER //
CREATE TRIGGER audit_accounts_before_update
BEFORE UPDATE ON accounts
FOR EACH ROW
BEGIN
  INSERT INTO audit_log(event_type, event_data)
  VALUES ('before_update', JSON_OBJECT('user', OLD.name, 'old_balance', OLD.balance, 'ts', NOW()));
END //
DELIMITER ;

-- Scenario: Enforce row-level access in a transaction (pseudo-code, for app logic or MySQL 8+ with roles).
-- Only allow UPDATE if CURRENT_USER() has access to the row.
-- (Implement with views, stored procedures, or app logic.)

-- Scenario: Simulate a deadlock between two sessions for learning and troubleshooting.
-- Session 1:
START TRANSACTION;
UPDATE accounts SET balance = balance - 10 WHERE name = 'Bob';
-- Session 2:
START TRANSACTION;
UPDATE accounts SET balance = balance - 10 WHERE name = 'Alice';
-- Session 1:
UPDATE accounts SET balance = balance - 10 WHERE name = 'Alice'; -- Waits/Deadlocks
-- Session 2:
UPDATE accounts SET balance = balance - 10 WHERE name = 'Bob';   -- Waits/Deadlocks
-- One session will get a deadlock error. Use SHOW ENGINE INNODB STATUS to analyze.

-- Scenario: Use multiple savepoints for granular rollback.
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE name = 'Bob';
SAVEPOINT s1;
UPDATE accounts SET balance = balance + 100 WHERE name = 'Alice';
SAVEPOINT s2;
UPDATE accounts SET balance = balance + 50 WHERE name = 'Eve';
-- Suppose this fails:
ROLLBACK TO s2; -- Only the last update is undone
-- Or ROLLBACK TO s1; -- Both Alice and Eve's updates are undone
COMMIT;

-- Scenario: Demonstrate write skew anomaly and how SERIALIZABLE prevents it.
-- Two doctors on call, only one must be on call at any time.
-- Session 1:
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT * FROM doctors WHERE on_call = 1;
-- Session 2:
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT * FROM doctors WHERE on_call = 1;
-- Both sessions see one doctor on call, both set themselves off call:
UPDATE doctors SET on_call = 0 WHERE name = 'Dr. A';
COMMIT;
-- Now, no doctor is on call! Use SERIALIZABLE to prevent this.

-- Scenario: Prevent phantom rows using gap locks (REPEATABLE READ).
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT * FROM accounts WHERE balance BETWEEN 1000 AND 2000 FOR UPDATE;
-- Session 2:
INSERT INTO accounts(name, balance) VALUES('Ghost', 1500); -- Will block until Session 1 commits
COMMIT;

-- Scenario: Use generated columns to enforce consistency within a transaction.
ALTER TABLE accounts ADD COLUMN balance_usd DECIMAL(15,2) GENERATED ALWAYS AS (balance * 1.1) STORED;
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE name = 'Bob';
-- balance_usd is always consistent with balance
COMMIT;

-- Scenario: Emulate 2PC across two MySQL databases (manual, not XA).
-- On DB1:
START TRANSACTION;
UPDATE db1.accounts SET balance = balance - 100 WHERE name = 'Bob';
-- On DB2:
START TRANSACTION;
UPDATE db2.accounts SET balance = balance + 100 WHERE name = 'Alice';
-- If both succeed, COMMIT both. If either fails, ROLLBACK both.

-- Scenario: Online schema change with zero downtime (requires Percona Toolkit).
-- Shell command, not SQL:
-- pt-online-schema-change --alter \"ADD COLUMN foo INT\" D=yourdb,t=accounts --execute
-- All changes are transactional and non-blocking.

-- Scenario: All committed transactions are streamed to Kafka for real-time analytics.
-- (Requires Debezium/MySQL binlog connector; not pure SQL, but critical for Uber-scale.)
-- All changes in a transaction are atomically published to Kafka topics.

-- Scenario: Ensure repeated transaction requests (e.g., retries) do not cause double processing.
START TRANSACTION;
INSERT INTO processed_transactions (txn_id, processed_at)
VALUES ('unique_txn_123', NOW())
ON DUPLICATE KEY UPDATE processed_at = NOW();
-- Only process if row was inserted, not updated
COMMIT;

-- Pseudo-code for app logic:
-- for attempt in 1..max_attempts:
--   try:
--     START TRANSACTION;
--     ...SQL operations...
--     COMMIT;
--     break;
--   except Deadlock:
--     sleep(2 ** attempt);
--     continue;

-- Scenario: Store and update complex state atomically using JSON columns.
START TRANSACTION;
UPDATE accounts SET profile = JSON_SET(profile, '$.status', 'active') WHERE name = 'Bob';
COMMIT;

-- Scenario: Chain audit log entries with hashes for tamper-evidence.
START TRANSACTION;
SET @last_hash = (SELECT hash FROM audit_log ORDER BY id DESC LIMIT 1);
INSERT INTO audit_log(event_type, event_data, hash)
VALUES (
  'debit',
  JSON_OBJECT('user', 'Bob', 'amount', 100, 'ts', NOW()),
  SHA2(CONCAT('debit', 'Bob', 100, NOW(), @last_hash), 256)
);
COMMIT;

-- Scenario: Mark outbox events as processed only after successful downstream delivery.
START TRANSACTION;
UPDATE outbox SET processed = 1, processed_at = NOW() WHERE id = 123 AND processed = 0;
COMMIT;

-- Scenario: Set lock wait timeout for transactions to avoid long waits.
SET innodb_lock_wait_timeout = 5;
START TRANSACTION;
-- ...do updates...
COMMIT;

-- Scenario: Enforce read-only transactions for reporting or analytics.
SET TRANSACTION READ ONLY;
START TRANSACTION;
SELECT SUM(balance) FROM accounts;
COMMIT;

-- Scenario: Ensure cross-region consistency with GTID and binlog position checks.
-- (Requires MySQL GTID replication; not pure SQL, but critical for global scale.)

-- Scenario: Demonstrate how MySQL's binlog and redo log (WAL) interact with transactions.
-- (Not directly visible in SQL, but you can tune durability and observe effects.)
SET GLOBAL sync_binlog = 1; -- Binlog is flushed to disk at each commit (max durability)
SET GLOBAL innodb_flush_log_at_trx_commit = 1; -- Redo log is flushed at each commit
-- Lower values increase performance but risk data loss on crash.

-- Scenario: MySQL does not support deferred foreign key checks, but you can emulate with triggers or app logic.
-- Mention in interviews: PostgreSQL supports DEFERRABLE INITIALLY DEFERRED constraints for true end-of-transaction checks.

-- Scenario: Ensure atomic updates across partitions.
ALTER TABLE accounts PARTITION BY HASH(id) PARTITIONS 4;
START TRANSACTION;
UPDATE accounts SET balance = balance - 10 WHERE id = 1;
UPDATE accounts SET balance = balance + 10 WHERE id = 2;
COMMIT;
-- All partition changes are atomic.

-- Scenario: Emulate materialized view refresh within a transaction.
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE name = 'Bob';
-- Manually refresh summary table
REPLACE INTO accounts_summary (total_balance)
SELECT SUM(balance) FROM accounts;
COMMIT;

-- Scenario: Emulate atomicity across sharded tables (manual 2PC or saga pattern).
-- In each shard:
START TRANSACTION;
UPDATE accounts_shard1 SET balance = balance - 100 WHERE name = 'Bob';
-- In another shard:
START TRANSACTION;
UPDATE accounts_shard2 SET balance = balance + 100 WHERE name = 'Alice';
-- Commit both if all succeed, else rollback both.

-- Scenario: Use outbox/inbox tables to coordinate with external systems (e.g., message queues).
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE name = 'Bob';
INSERT INTO outbox(event_type, payload) VALUES ('debit', '{\"user\":\"Bob\",\"amount\":100}');
COMMIT;
-- Downstream service reads outbox and delivers to external system.

-- Scenario: Maintain a full history of changes within a transaction.
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE name = 'Bob';
INSERT INTO accounts_history SELECT *, NOW() AS changed_at FROM accounts WHERE name = 'Bob';
COMMIT;

-- Scenario: Apply a JSON patch atomically to a document column.
START TRANSACTION;
UPDATE accounts SET profile = JSON_MERGE_PATCH(profile, '{\"status\":\"inactive\"}') WHERE name = 'Bob';
COMMIT;

-- Scenario: Use a version column to prevent lost updates (optimistic locking).
START TRANSACTION;
UPDATE accounts SET balance = balance - 100, version = version + 1
WHERE name = 'Bob' AND version = 5;
-- If row count = 0, someone else updated first; retry.
COMMIT;

-- Scenario: Explicitly release savepoints to free resources.
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE name = 'Bob';
SAVEPOINT s1;
UPDATE accounts SET balance = balance + 100 WHERE name = 'Alice';
RELEASE SAVEPOINT s1;
COMMIT;

