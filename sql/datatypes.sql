-- # DATE
SET TIME ZONE 'UTC';
SELECT NOW();


SELECT TO_CHAR(NOW(), 'YYYY-MM-DD');
SELECT TO_CHAR(NOW(), 'HH24:MI:SS');

SELECT TO_TIMESTAMP('2024-11-27 15:30:00', 'YYYY-MM-DD HH24:MI:SS');
SELECT TO_DATE('2024-11-27', 'YYYY-MM-DD');

SELECT TO_CHAR(CURRENT_DATE, 'Mon dd, yyyy');

SELECT EXTRACT(YEAR FROM NOW());
SELECT EXTRACT(DAY FROM CURRENT_DATE);
SELECT DATE_PART('month', NOW());

SELECT AGE(TIMESTAMP '2020-01-01', TIMESTAMP '2010-01-01');

-- Manipulating Dates
SELECT CURRENT_DATE + INTERVAL '1 day';
SELECT CURRENT_DATE - INTERVAL '7 days';

SELECT INTERVAL '1 hour' * 3;
SELECT NOW() + MAKE_INTERVAL(days => 7);

SELECT '2024-11-27'::DATE = '2024-11-27'::DATE;
SELECT '2024-11-27'::DATE > '2024-11-20'::DATE;

-- RANGE Query on DATE
SELECT *
FROM orders
WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31';

SELECT DATE_TRUNC('month', NOW());
SELECT DATE_TRUNC('year', TIMESTAMP '2024-11-27 15:30:00');

SELECT EXTRACT(EPOCH FROM NOW());

SELECT TO_TIMESTAMP(1700000000);

-- Generating Dates from 2024-01-01 (1st Jan) to 2024-01-10 (10th Jan)

SELECT GENERATE_SERIES(DATE '2024-01-01', DATE '2024-01-10', INTERVAL '1 day');
SELECT CURRENT_DATE + (RANDOM() * 10)::INT;

-- Calculating Days Between Dates:
SELECT '2024-11-27'::DATE - '2024-11-20'::DATE;

-- Finding the next monday
SELECT CURRENT_DATE + (7 - EXTRACT(DOW FROM CURRENT_DATE))::INT;

-- Grouping by date or time period
SELECT DATE_TRUNC('month', order_date) AS month, COUNT(*)
FROM orders
GROUP BY DATE_TRUNC('month', order_date);

SELECT NOW() + INTERVAL '1 year 2 months 3 days';
SELECT EXTRACT(DAY FROM INTERVAL '1 year 2 months 3 days');

-- Raises an error if the string is invalid.
SELECT '2024-11-27'::DATE;

-- Get the interval between two dates
SELECT first_name, last_name, now() - hire_date as diff
FROM employees;

-- Calculate ages in years, months, and days
SELECT employee_id, first_name, last_name, AGE(birth_date)
FROM employees;

-- Extract year, quarter, month, week, and day from a date value : To get the year, quarter, month, week, and day from a date value, you use the EXTRACT() function.
SELECT employee_id,
       first_name,
       last_name,
       EXTRACT(YEAR FROM birth_date)  AS YEAR,
       EXTRACT(MONTH FROM birth_date) AS MONTH,
       EXTRACT(DAY FROM birth_date)   AS DAY
FROM employees;

-- # INTERVAL
SELECT now(), now() - INTERVAL '1 year 3 hours 20 minutes' AS "3 hours 20 minutes ago of last year";

SELECT INTERVAL '2h 50m' + INTERVAL '10m'; -- 03:00:00
SELECT INTERVAL '2h 50m' - INTERVAL '50m'; -- 02:00:00
SELECT 600 * INTERVAL '1 minute'; -- 10:00:00

SELECT TO_CHAR(
               INTERVAL '17h 20m 05s',
               'HH24:MI:SS');

SELECT EXTRACT(
               MINUTE
               FROM
               INTERVAL '5 hours 21 minutes'
       );

SELECT justify_days(INTERVAL '30 days'),
       justify_hours(INTERVAL '24 hours');

CREATE TABLE IF NOT EXISTS event
(
    id         SERIAL PRIMARY KEY,
    event_name VARCHAR(255) NOT NULL,
    duration   INTERVAL     NOT NULL
);

INSERT INTO event (event_name, duration)
VALUES ('pgConf', '1 hour 30 minutes'),
       ('pgDAY', '2 days 5 hours')
RETURNING *;

SELECT event_name,
       duration,
       EXTRACT(DAY FROM duration)    AS days,
       EXTRACT(HOUR FROM duration)   AS hours,
       EXTRACT(MINUTE FROM duration) AS minutes
FROM event;

SELECT *
FROM event
WHERE duration > INTERVAL '1 day';

SELECT SUM(duration) AS total_duration
FROM event;

WITH cte AS (SELECT SUM(duration) AS total_duration
             FROM event)
SELECT total_duration,
       EXTRACT(DAY FROM total_duration)    AS days,
       EXTRACT(HOUR FROM total_duration)   AS hours,
       EXTRACT(MINUTE FROM total_duration) AS minutes
FROM cte;

-- # TIME
CREATE TABLE IF NOT EXISTS shifts
(
    id         serial PRIMARY KEY,
    shift_name VARCHAR NOT NULL,
    start_at   TIME    NOT NULL,
    end_at     TIME    NOT NULL
);

INSERT INTO shifts(shift_name, start_at, end_at)
VALUES ('Morning', '08:00:00', '12:00:00'),
       ('Afternoon', '13:00:00', '17:00:00'),
       ('Night', '18:00:00', '22:00:00');

select *
from shifts;

SELECT CURRENT_TIME;

SELECT CURRENT_TIME(5);

SELECT LOCALTIME;

SELECT LOCALTIME(0);

SELECT LOCALTIME AT TIME ZONE 'UTC-7';

SELECT time '10:00' - time '02:00' AS result;

SELECT LOCALTIME + interval '2 hours' AS result;

-- # REAL: Typically, you use the REAL data type to store floating-point numbers with relatively large ranges and precision is not critical, or when you are concerned about the storage space.
-- For the utmost precision on FLOAT, use the DOUBLE PRECISION

-- # UUID: A UUID value is a 128-bit quantity generated by an algorithm that makes it unique in the known universe using the same algorithm.
SELECT gen_random_uuid();

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
SELECT uuid_generate_v4(); -- To use the v4 the above line needs to executed

CREATE TABLE IF NOT EXISTS contacts
(
    contact_id    uuid DEFAULT gen_random_uuid(),
    customer_name VARCHAR NOT NULL,
    email         VARCHAR NOT NULL,
    phone         VARCHAR,
    PRIMARY KEY (contact_id),
    customer_id   INT     NOT NULL,
    FOREIGN KEY (customer_id) REFERENCES customer (customer_id) ON DELETE CASCADE
);



select *
from customer;

select *
from contacts;

INSERT INTO contacts (customer_name, email, phone, customer_id)
VALUES ('John Smith', '[[email protected]](../cdn-cgi/l/email-protection.html)', '408-237-2345', 1),
       ('Jane Smith', '[[email protected]](../cdn-cgi/l/email-protection.html)', '408-237-2344', 2),
       ('Alex Smith', '[[email protected]](../cdn-cgi/l/email-protection.html)', '408-237-2343', 5)
RETURNING *;



select cu.customer_id, co.customer_id, customer_name, co.email, co.phone, co.phones
from contacts co
         INNER JOIN customer cu on co.customer_id = cu.customer_id;

-- # ARRAY

ALTER TABLE contacts
    ADD COLUMN phones TEXT[] DEFAULT '{}'; -- {} means an empty array

UPDATE contacts
SET phones = '{}'; -- update phones value to empty array i.e. '{}' for all existing rows on contacts

INSERT INTO contacts (customer_name, email, phone, customer_id, phones)
VALUES ('Jones Doe', 'jones@example.com', '100-220-550', 2, '{"(408)-589-5846","(408)-589-5555"}')
RETURNING *;

SELECT customer_name, phones[1]
FROM contacts;

SELECT customer_name
FROM contacts
WHERE phones[1] = '(408)-589-5846';

-- overwrite the first element of the array where customer_id = 1
UPDATE contacts
SET phones[1] = '(408)-589-5843'
WHERE customer_id = 1
RETURNING *;

-- overwrite the array where customer_id = 1

UPDATE
    contacts
SET phones = '{"(408)-589-5843"}'
WHERE customer_id = 1
RETURNING *;

-- Suppose, you want to know who has the phone number (408)-589-5555 regardless of the position of the phone number in the phones array, you can use ANY() function as follows:

SELECT customer_name,
       phones
FROM contacts
WHERE '(408)-589-5555' = ANY (phones);

-- Expanding Arrays: PostgreSQL provides the unnest() function to expand an array to a list of rows. For example, the following query expands all phone numbers of the phones array.

SELECT customer_name,
       unnest(phones)
FROM contacts
where customer_id = 2;

select *
from contacts;

CREATE TABLE IF NOT EXISTS product
(
    id         SERIAL PRIMARY KEY,
    name       VARCHAR(255) NOT NULL,
    properties JSONB
);

INSERT INTO product(name, properties)
VALUES ('Ink Fusion T-Shirt', '{
  "color": "white",
  "size": [
    "S",
    "M",
    "L",
    "XL"
  ]
}')
RETURNING *;

INSERT INTO product(name, properties)
VALUES ('ThreadVerse T-Shirt', '{
  "color": "black",
  "size": [
    "S",
    "M",
    "L",
    "XL"
  ]
}'),
       ('Design Dynamo T-Shirt', '{
         "color": "blue",
         "size": [
           "S",
           "M",
           "L",
           "XL"
         ]
       }')
RETURNING *;

SELECT id, name, properties
FROM product;

SELECT id,
       name,
       properties -> 'size' size
FROM product;

SELECT id,
       name,
       properties ->> 'color' color
FROM product
WHERE properties ->> 'color' IN ('black', 'white');


CREATE TABLE IF NOT EXISTS contacts2
(
    id     SERIAL PRIMARY KEY,
    name   VARCHAR(255) NOT NULL,
    phones JSONB
);

INSERT INTO contacts2(name, phones)
VALUES ('John Doe', '[
  "408-111-2222",
  "408-111-2223"
]'),
       ('Jane Doe', '[
         "212-111-2222",
         "212-111-2223"
       ]')
RETURNING *;

SELECT name,
       phones ->> 0 "work phone" -- from phones , take the value first index
FROM contacts2;

-- # User-defined Data Types

DROP TABLE IF EXISTS mailing_list;

-- This will work fine but instead of defining constraints
CREATE TABLE IF NOT EXISTS mailing_list
(
    id         SERIAL PRIMARY KEY,
    first_name VARCHAR NOT NULL,
    last_name  VARCHAR NOT NULL,
    email      VARCHAR NOT NULL,
    CHECK (
        first_name !~ '\s'
            AND last_name !~ '\s'
        )
);

-- But, a domain could be used for reusability
CREATE DOMAIN contact_name AS VARCHAR NOT NULL CHECK (value !~ '\s');

CREATE TABLE mailing_list
(
    id         serial PRIMARY KEY,
    first_name contact_name,
    last_name  contact_name,
    email      VARCHAR NOT NULL
);

INSERT INTO mailing_list (first_name, last_name, email)
VALUES ('Jane', 'Doe', '[[email protected]](../cdn-cgi/l/email-protection.html)');

select *
from mailing_list;

-- The following statement returns domains from the public schema of the current database:

SELECT typname
FROM pg_catalog.pg_type
         JOIN pg_catalog.pg_namespace
              ON pg_namespace.oid = pg_type.typnamespace
WHERE typtype = 'd'
  and nspname = 'public';

-- The CREATE TYPE statement allows you to create a composite type, which can be used as the return type of function.
-- Suppose you want to have a function that returns several values: film_id, title, and release_year. The first step is to create a type e.g., film_summary as follows:

CREATE TYPE film_summary AS
(
    film_id      INT,
    title        VARCHAR,
    release_year SMALLINT
);

CREATE OR REPLACE FUNCTION get_film_summary(f_id INT)
    RETURNS film_summary AS
$$
DECLARE
    result film_summary;
BEGIN
    SELECT film_id,
           title,
           release_year
    INTO result
    FROM film
    WHERE film_id = f_id;

    RETURN result;
END;
$$
    LANGUAGE plpgsql;

SELECT *
FROM get_film_summary(20);

-- # ENUM
CREATE TYPE priority AS ENUM ('low','medium','high');

CREATE TABLE requests
(
    id           INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    title        VARCHAR(255) NOT NULL,
    priority     PRIORITY     NOT NULL,
    request_date DATE         NOT NULL
);

INSERT INTO requests(title, priority, request_date)
VALUES ('Create an enum tutorial in PostgreSQL', 'high', '2019-01-01'),
       ('Review the enum tutorial', 'medium', '2019-01-01'),
       ('Publish the PostgreSQL enum tutorial', 'low', '2019-01-01')
RETURNING *;

SELECT *
FROM requests
ORDER BY priority; -- since low (0), medium(1) and high (2)

SELECT *
FROM requests
WHERE priority > 'low' -- so find all rows i.e. > low (0)
ORDER BY priority;

SELECT *
FROM requests
WHERE priority = 'HIGH' -- it is case-sensitive so error and it should `high`
ORDER BY priority;

INSERT INTO requests(title, priority, request_date)
VALUES ('Revise the enum tutorial', 'urgent',
        '2019-01-02') -- here priority only accepts low, medium or high so urgent is not valid enum value
RETURNING *;

-- Adding new values to enums: To add a new value to an enum, you use the ALTER TYPE ... ADD VALUE statement:

ALTER TYPE priority ADD VALUE 'urgent';

INSERT INTO requests(title, priority, request_date)
VALUES ('Revise the enum tutorial', 'urgent',
        '2019-01-02') -- here priority only accepts low, medium or high so urgent is not valid enum value
RETURNING *;

-- Retrieve all enums from a specific enum i.e. priority
SELECT enum_range(null::priority);

SELECT enum_first(NULL::priority) first_value, enum_last(NULL::priority) last_value;

ALTER TYPE priority RENAME VALUE 'urgent' TO 'very high';

SELECT enum_range(null::priority);

-- # XML

-- Add the XML column
ALTER TABLE person
    ADD COLUMN info XML;

-- Update the info column with XML data
UPDATE person
SET info = XMLPARSE(DOCUMENT '<?xml version="1.0" encoding="UTF-8"?>
<person>
    <name>John Doe</name>
    <age>35</age>
    <city>San Francisco</city>
</person>');

INSERT INTO person (first_name, last_name, email, info)
VALUES ('Jane', 'Doe', 'james@gmail.com', XMLPARSE(DOCUMENT '<?xml version="1.0" encoding="UTF-8"?>
    <person>
        <name>Jane Doe</name>
        <age>30</age>
        <city>San Francisco</city>
    </person>')),
       ('John', 'Smith', 'jones@gmail.com', XMLPARSE(DOCUMENT '<?xml version="1.0" encoding="UTF-8"?>
    <person>
        <name>John Smith</name>
        <age>40</age>
        <city>New York</city>
    </person>')),
       ('Alice', 'Johnson', 'jose@gmail.com', XMLPARSE(DOCUMENT '<?xml version="1.0" encoding="UTF-8"?>
    <person>
        <name>Alice Johnson</name>
        <age>30</age>
        <city>Los Angeles</city>
    </person>'));

select *
from person;

-- Fourth, retrieve the names of persons from the XML documents using xpath() function:
SELECT xpath('/person/name/text()', info) AS name
FROM person;

-- Fourth, retrieve person names as text from the XML documents using xpath() function:
SELECT (xpath('/person/name/text()', info))[1]::text AS name
FROM person;

-- retrieve the ages of persons:
SELECT (xpath('/person/age/text()', info))[1]::text::integer AS age
FROM person;

SELECT (xpath('/person/name/text()', info))[1]::text         AS name,
       (xpath('/person/age/text()', info))[1]::text::integer AS age,
       (xpath('/person/city/text()', info))[1]::text         AS city
FROM person;

SELECT *
FROM person
WHERE (xpath('/person/name/text()', info))[1]::text = 'Jane Doe';

-- First, create an index expression that extracts the name of a person as an array of text:

CREATE INDEX IF NOT EXISTS person_name
    ON person USING BTREE
        (cast(xpath('/person/name', info) as text[]));


-- Second, create a function that inserts 1000 rows into the person table for testing purposes:

CREATE OR REPLACE FUNCTION generate_persons()
RETURNS void AS
$$
BEGIN
    INSERT INTO person (info)
    SELECT
        XMLPARSE(DOCUMENT '<?xml version="1.0" encoding="UTF-8"?>
        <person>
            <name>' || 'Person' || generate_series || '</name>
            <age>' || (generate_series % 80 + 18) || '</age>
            <city>' || CASE WHEN generate_series % 3 = 0 THEN 'New York'
                            WHEN generate_series % 3 = 1 THEN 'Los Angeles'
                            ELSE 'San Francisco' END || '</city>
        </person>')
    FROM generate_series(1, 1000);
END;
$$ LANGUAGE plpgsql;

SELECT generate_persons();

EXPLAIN ANALYZE
SELECT *
FROM person
WHERE cast(xpath('/person/name', info) as text[]) = '{<name>Jane Doe</name>}';

-- # BYTEA is a binary data type that you can use to store binary strings or byte sequences. BYTEA stands for the binary array.
-- The maximum size of a BYTEA column is 1GB. It means you can only store binary data up to 1GB in a single BYTEA column.
-- However, storing a large amount of binary data in a BYTEA column is not efficient.
-- If files are larger than a few megabytes, you can store them externally and save the paths to the files in the database.

CREATE TABLE IF NOT EXISTS binary_data(
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    data BYTEA
);

INSERT INTO binary_data(data) VALUES ('\x012345');

SELECT * FROM binary_data;

-- # Composite Types: allow you to define custom data types with multiple fields. These fields can be any built-in or user-defined types, including other composite types

CREATE TYPE address_type AS(
   street text,
   city text,
   state text,
   zip_code integer,
   country text
);

-- After defining a composite type, you can use it as a data type of table column.
-- For example, the following statement creates a table called contacts whose type of address column is the address_type:

CREATE TABLE IF NOT EXISTS contacts4(
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    address address_type
);

INSERT INTO contacts4 (name, address)
VALUES (
    'John Smith',
    ROW('123 St', 'Houston', 'TX', 77001, 'USA')
);

-- The following statement inserts a value into individual fields of the address column:

-- INSERT INTO contacts4 (
--     name,
--     address.street,
--     address.city,
--     address.state,
--     address.zip_code
--   )
-- VALUES ('Jane Doe', '4000 N. 1st Street', 'San Jose', 'CA', 95134);

select * from contacts4;

SELECT
  id,
  name,
  (address).city,
  (address).state,
  (address).zip_code
FROM
  contacts4;

-- If you retrieve all fields from a composite value, you can use the asterisk (*) shorthand:

SELECT
  id,
  name,
  (address).*
FROM
  contacts4;

-- The following example updates the country of the contact id 2 to the USA:
UPDATE contacts4
SET
  address.country= 'USA'
WHERE
  id = 2
RETURNING *;