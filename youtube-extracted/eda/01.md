[Fowler's EDA Talk][resource]

[resource]: https://youtu.be/STKCRSUsyP0?list=TLGGc5i3Kc6m_PMyOTExMjAyNQ

# Event-Driven Architecture: Four Key Patterns

## Context & Motivation

Martin Fowler's 2017 talk identifying four distinct patterns commonly lumped under "event-driven architecture." Based on a ThoughtWorks workshop where teams realized they were doing different things under the same term.

**Why this matters:** "Event-driven" is too vague - like "service-oriented architecture" before microservices. These patterns provide precision for discussing system design and trade-offs.

## Pattern 1: Event Notification

### What It Is
- Systems emit events when state changes
- Other systems subscribe/listen to these events
- Reverses dependencies: consumers know about producers, not vice versa

### Example: Insurance Company
- Customer Management System emits "CustomerAddressChanged" event
- Insurance Quoting System listens and recalculates quotes
- GUI systems use this pattern (textbox changes emit events, code listens)

### Benefits
- **Dependency Reversal:** Generic systems don't need to know about specific consumers
- **First-Class Events:** Changes become persistent objects you can reference and pass around
- **Easy Extension:** New consumers can tap into existing event streams without modifying producers

### Trade-offs
- **Debugging Complexity:** No code shows "what happens when X changes" - must trace event flows
- **Observability Issues:** Hard to understand system behavior by reading code alone

### When to Use
Most common pattern - used in almost every system to some degree. Becomes "event-driven" when seen as architecturally significant.

## Pattern 2: Event-Carried State Transfer

### What It Is
Evolution of event notification where events carry complete state data, eliminating need for consumers to query producers.

### Example: Insurance Company Extended
- Events include full customer data (old address, new address, all relevant fields)
- Consumers maintain their own copies of needed data
- No callbacks to original system needed

### Benefits
- **Performance:** Eliminates network calls to source systems
- **Availability:** Consumers work even if source system is down
- **Load Reduction:** Source system doesn't handle consumer queries

### Trade-offs
- **Eventual Consistency:** Data duplication means consistency issues
- **Storage Costs:** More data copying (though storage is cheap)
- **Complexity:** Managing duplicated state across systems

### When to Use
Less common, deeper in the toolbox. Good when you need high availability and can tolerate eventual consistency.

## Pattern 3: Event Sourcing

### What It Is
- Store complete log of all changes (events) that ever occurred
- Application state is derived by replaying these events
- Can rebuild current state from event log at any time

### Core Test
Can you blow away your application state and confidently rebuild it from the event log?

### Familiar Examples
- **Version Control:** Git commits = events, working directory = application state
- **Accounting Ledgers:** Every credit/debit is an event, current balance is derived state

### Benefits
- **Audit Trail:** Perfect record of what happened and why
- **Time Travel:** Debug by replaying events, restore to any point in time
- **Alternative States:** Branching/testing different scenarios
- **Complex Logic Handling:** Easy to recalculate complex business rules (e.g., payroll adjustments)
- **Memory Image Systems:** Can run entirely in-memory with event log as persistence

### Real-World Example: ELMAX Trading System
- 6 million transactions/second on single thread
- Everything in memory, rebuilt from event logs nightly
- Hot backups via multiple systems reading same event stream

### Trade-offs & Challenges
- **Unfamiliarity:** Harder to work with than traditional CRUD
- **External Systems:** Must handle/capture responses from external APIs as events
- **Versioning Complexity:** Schema changes while maintaining replayability
- **Asynchrony:** Often introduces async processing complexity
- **Event Schema Design:** What to store vs. derive

### When to Use
Powerful but complex. Great for audit-heavy systems, complex business logic, high-performance needs.

## Pattern 4: CQRS (Command Query Responsibility Segregation)

### What It Is
- Separate models for reading vs. writing data
- Command model handles updates (complex business logic)
- Query model optimized for reads (often denormalized/precalculated)

### Key Principle
Command model never used for reading - completely separate components.

### Example
- Write model handles complex quote calculations
- Read model stores pre-calculated data for fast UI display
- Updates happen much less frequently than reads

### Benefits
- **Performance:** Optimized read models for high-volume queries
- **Separation of Concerns:** Different models for different purposes
- **Scalability:** Can scale read/write models independently

### Trade-offs & Challenges
- **Complexity:** Two models to maintain and sync
- **Over-application:** Often confused with simple read/write separation
- **When to Use:** Deep in toolbox - requires careful evaluation

### Common Confusion
Not just having separate databases for OLTP vs. reporting - that's been done for years. CQRS means the command model is never used for reads.

## Key Insights

### Events vs. Commands
- **Events:** "Customer address changed" (declarative, no specific expectations)
- **Commands:** "Requote insurance for customer" (imperative, expects action)
- Same underlying mechanism, but naming conveys intent and expectations

### Practical Applications
- **Debugging:** Event sourcing provides excellent debugging capabilities
- **Audit:** Essential for financial/regulatory compliance
- **Performance:** Event-carried state transfer for high-throughput systems
- **Extensibility:** Event notification for loosely-coupled systems

### Common Pitfalls
- **Asynchrony Confusion:** Event sourcing â‰  asynchronous processing (though often combined)
- **Versioning:** Critical in event-sourced systems - Greg Young has extensive guidance
- **Over-engineering:** Start with event notification, evolve as needed

### Value Proposition
These patterns provide **precision** in architectural discussions, replacing vague "event-driven" terminology with specific, well-understood approaches with known trade-offs.

**Resources:** Fowler's original article with links to ELMAX, event sourcing guides, and Greg Young's work.